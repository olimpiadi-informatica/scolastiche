{"version":3,"file":"ec3fcecb-question.js","sources":["../../../../src/fibonacci-primarie/2025-prima-fase/contest/a-2-piega-e-taglia/question.md","../../../../src/fibonacci-primarie/2025-prima-fase/contest/a-3-pile-di-libri/question.md","../../../../src/fibonacci-primarie/2025-prima-fase/contest/a-4-frutti-misteriosi/question.md","../../../../src/fibonacci-primarie/2025-prima-fase/contest/p-2-strade/question.md"],"sourcesContent":["import variants from \"./variants.py\";\n\nBunny vuole fare delle decorazioni per Natale!\nHa piegato un foglio quadrato come in figura e poi ha tagliato lungo la linea tratteggiata.\n\n\n![immagine](img1.asy?v=variants.py)\n\nQuale di queste figure ottiene Bunny quando riapre il foglio dopo averlo tagliato?\n\n- [x] <span>![A](ans1.asy?v=variants.py&s=0.8)</span>\n- [ ] <span>![B](wrong1a.asy?v=variants.py&s=0.8)</span> \n- [ ] <span>![C](wrong1b.asy?v=variants.py&s=0.8)</span>\n- [ ] <span>![D](wrong1c.asy?v=variants.py&s=0.8)</span>\n- [ ] <span>![A](wrong1d.asy?v=variants.py&s=0.8)</span>\n\n> Dopo aver piegato il foglio come in figura, la linea di ritaglio corrisponde\n> a quello che si potrà vedere nel quarto di foglio in alto a sinistra, una volta riaperto,\n> con le altri parti del foglio che avranno la versione ribaltata della stessa forma:\n>\n> ![foglio](foglio_riaperto.asy)\n> \n> Quindi la figura che si ottiene sarà:\n> \n> ![risposta](ans1.asy?v=variants.py&s=0.8)\n\n---\n\nOra Bunny vuole ottenere questa forma quando riapre il foglio:\n\n![immagine](img2.asy?v=variants.py)\n\nQuale taglio deve fare?\n\n- [x] <span>![A](ans2.asy?v=variants.py&s=0.95)</span>\n- [ ] <span>![B](wrong2a.asy?v=variants.py&s=0.95)</span>\n- [ ] <span>![C](wrong2b.asy?v=variants.py&s=0.95)</span>\n- [ ] <span>![D](wrong2c.asy?v=variants.py&s=0.95)</span>\n- [ ] <span>![A](wrong2d.asy?v=variants.py&s=0.95)</span>\n\n> Per lo stesso ragionamento di prima, dobbiamo guardare il quarto di foglio in alto a sinistra,\n> e vedere cosa manca e cioè dove è stato tagliato.\n> Quindi il taglio che è stato fatto deve essere questo:\n>\n> ![ans2](ans2.asy?v=variants.py&s=0.95)","import variants from \"./variants.py\";\n\nTip-Tap ha $\\js{n}$ pile di libri di varie altezze.\nQuanti libri deve **aggiungere** per portare tutte le pile alla stessa altezza?\n\n![immagine](immagine.asy?v=variants.py)\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Siccome non si possono rimuovere libri, tutte le pile devono raggiungere l'altezza della pila più alta.\n> Quindi il risultato si ottiene sommando per ogni pila la differenza di altezza tra la pila più alta e quella pila:\n> in questo caso $\\js{h-altezze[0]} + \\js{h-altezze[1]} + \\js{h-altezze[2]} + \\js{h-altezze[3]} + \\js{h-altezze[4]} = \\js{ans1}$.\n\n---\n\nPensandoci meglio, Tip-Tap ha deciso che può **spostare** i libri che ci sono da una pila all'altra, prima di **aggiungere** nuovi libri.\nVuole spostare e aggiungere meno libri possibile. Quanti libri deve **spostare o aggiungere** per portare tutte le pile alla stessa altezza?\n\n- [x] $\\js{ans2}$\n- [ ] $\\js{wrong2[0]}$\n- [ ] $\\js{wrong2[1]}$\n- [ ] $\\js{wrong2[2]}$\n- [ ] $\\js{wrong2[3]}$\n\n> Spostare i libri è sempre conveniente rispetto ad aggiungere, perché alza la pila più bassa mentre abbassa la pila più alta, avvicinando le altezze delle pile.\n> Spostando i libri, possiamo portare tutte le pile all'altezza media arrotondata per eccesso, che in questo caso è $\\js{hf}$.\n> Il numero di aggiunte o spostamenti sarà quindi pari a quanto manca ad ogni pila per arrivare a $\\js{hf}$, contando zero per le pile già più alte:\n> $\\js{Math.max(hf-altezze[0],0)} + \\js{Math.max(hf-altezze[1],0)} + \\js{Math.max(hf-altezze[2],0)} + \\js{Math.max(hf-altezze[3],0)} + \\js{Math.max(hf-altezze[4],0)} = \\js{ans2}$.\n","import variants from \"./variants.py\";\n\nAllie ha comprato alcuni frutti. Ha provato a pesarli sulla sua bilancia, come vedi qui:\n\n<div class=\"print:hidden\">\n![scale1](scale1.asy?v=variants.py)\n![scale2](scale2.asy?v=variants.py)\n</div>\n\n<div class=\"hidden print:block\">\n![scale1](scale1.asy?v=variants.py)\n\n![scale2](scale2.asy?v=variants.py)\n</div>\n\nIn tutte e due le prove le bilance sono squilibrate! Il peso totale dei frutti a destra è maggiore del peso totale dei frutti a sinistra.\nSai che i frutti di tipo uguale pesano tutti uguale. Qual è l'ordine di peso dei frutti (dal più leggero al più pesante)?\n\n- [ ] <span>![A](A.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![B](B.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![C](C.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![D](D.asy?v=variants.py&s=0.6)</span>\n- [x] <span>![E](E.asy?v=variants.py&s=0.6)</span>\n\n> Dalla prima pesata, togliendo da entrambi i piatti una {names[perm[2]]} (frutti uguali hanno sempre lo stesso peso!), capiamo che la {names[perm[0]]} pesa meno che la {names[perm[1]]}.\n> Con la seconda pesata capiamo invece che la {names[perm[2]]} pesa più della {names[perm[1]]}. Infatti, se sostituiamo nel piatto destro la {names[perm[0]]} con la {names[perm[1]]}\n> (che è più pesante), quel piatto deve rimanere il più pesante.\n> Di conseguenza l'ordine è {names[perm[0]]} (leggero) - {names[perm[1]]} (medio) - {names[perm[2]]} (pesante).\n\n---\n\nAllie ha comprato anche alcune verdure: patate, carote e melanzane. Le pesa sulla bilancia, come vedi qui:\n\n<div class=\"print:hidden\">\n![scale3](scale3.asy?v=variants.py)\n![scale4](scale4.asy?v=variants.py)\n</div>\n\n<div class=\"hidden print:block\">\n![scale3](scale3.asy?v=variants.py)\n\n![scale4](scale4.asy?v=variants.py)\n</div>\n\nCosa puoi capire sul peso di queste tre verdure?\n\n- [x] la {names[perm[3]]} è la più leggera, ma non si sa niente sulle altre due verdure\n- [ ] la {names[perm[3]]} è la più leggera, la {names[perm[5]]} è intermedia e la {names[perm[4]]} è la più pesante\n- [ ] la {names[perm[5]]} è la più leggera, ma non si sa niente sulle altre due verdure\n- [ ] la {names[perm[4]]} è la più leggera, la {names[perm[5]]} è intermedia e la {names[perm[3]]} è la più pesante\n- [ ] non si sa niente sui pesi delle tre verdure\n\n> Togliendo da ognuna delle pesate le verdure presenti su entrambi i piatti, possiamo vedere che sia la {names[perm[4]]} che la {names[perm[5]]}\n> sono più pesanti della media delle altre due verdure. L'unico caso in cui questo può succedere è se la {names[perm[3]]} è la verdura più leggera.\n> Invece, non possiamo dire nulla su {names[perm[4]]} e {names[perm[5]]}: infatti, la seconda pesata è identica alla prima scambiando\n> {names[perm[4]]} con {names[perm[5]]}, e quindi tutto quello che si potrebbe dire di una delle due verdure si dovrebbe poter dire anche dell'altra.","import variants from \"./variants.py\";\n\nCarol adora i labirinti, allora ha costruito questo nella Fattoria Fibonacci:\n\n![Immagine](immagine1.asy?v=variants.py)\n\nI corridoi in cui si può passare sono le **linee nere dritte**, che si incontrano tra loro in alcuni **incroci**.\nSi entra nel labirinto dal **quadrato verde** in posizione **A1**.\nSe per esempio da quel punto Carol _avanza fino al prossimo incrocio_, arriva in posizione **{examples[0]}** ({examples_exp[0]}). Se poi _gira a sinistra_ e di nuovo _avanza fino al prossimo incrocio_, arriva in posizione **{examples[1]}** ({examples_exp[1]}).\n\nCarol esplora il labirinto seguendo questo procedimento:\n\n![Codice](codice.asy?s=0.7)\n\nIn che posizione arriva alla fine del procedimento?\n\n- [ ] in posizione **{wrong_fy[0]}{wrong_fx[0]}**\n- [ ] in posizione **{wrong_fy[1]}{wrong_fx[1]}**\n- [x] in posizione **{fy}{fx}**\n- [ ] in posizione **{wrong_fy[2]}{wrong_fx[2]}**\n- [ ] in posizione **{wrong_fy[3]}{wrong_fx[3]}**\n\n> Seguendo la procedura indicata, Carol farà questo percorso:\n> \n> {path[0]} → {path[1]} → {path[2]} → {path[3]} → {path[4]} → \n> {path[5]} → {path[6]} → {path[7]} → {path[8]} → {path[9]}\n> \n> La risposta è quindi **{path[8]}**.\n\n---\n\nCarol ha sentito che in posizione **{qsy}{qx+1}** (cerchio rosso nella griglia sopra) hanno nascosto una carota speciale! Allora vuole ripetere le tre operazioni di prima (avanza, avanza, gira) **finché non ci arriva**.\nPartendo sempre dall'entrata in posizione **A1**, quante volte le deve ripetere per arrivare in posizione **{qsy}{qx+1}**?\n\n- [ ] $\\js{wrong[0]}$\n- [ ] $\\js{wrong[1]}$\n- [ ] $\\js{wrong[2]}$\n- [x] $\\js{ans}$\n- [ ] $\\js{wrong[3]}$\n\n> Per arrivare in posizione **{qsy}{qx+1}** deve ripetere il ciclo $\\js{ans}$ volte, facendo questo percorso:\n>\n> {cpath}\n"],"names":["_jsx","Equation","_components","_jsxs","Image","names","perm","examples","examples_exp","wrong_fy","wrong_fx","fy","fx","path","qsy","qx","cpath"],"mappings":"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"}