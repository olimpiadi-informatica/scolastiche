{"version":3,"file":"e8cb8958-page.js","sources":["../../../../src/scolastiche/2025/contest/a-3s-pile-di-libri/question.md","../../../../src/scolastiche/2025/contest/a-4s-frutti-misteriosi/question.md","../../../../src/scolastiche/2025/contest/a-5-pianificazione-stradale/question.md","../../../../src/scolastiche/2025/contest/a-6-alberi-bloccati/question.md","../../../../src/scolastiche/2025/contest/a-8-lampadine/question.md","../../../../src/scolastiche/2025/contest/p-3s-panini-chioschi/question.md","../../../../src/scolastiche/2025/contest/a-7-discariche/question.md","../../../../src/scolastiche/2025/contest/p-5-rosso-e-nero/question.md","../../../../src/scolastiche/2025/contest/p-4s-luci-porte/question.md","../../../../src/scolastiche/2025/contest/p-6-array-e-bit/question.md","../../../../src/scolastiche/2025/contest/contest.mdx","../../../../src/scolastiche/2025/header.md","../../../../src/scolastiche/2025/page.tsx"],"sourcesContent":["import variants from \"./variants.py\";\n\nPer la verifica di _greco antico_ devi studiare $\\js{n}$ pile di libri di varie altezze.\nMentre li osservi, raccogliendo le forze per iniziare a leggerli, sei un po' infastidito dal fatto che le pile hanno altezze diverse.\nQuanti libri dovresti **aggiungere** al minimo per portare tutte le pile alla stessa altezza?\n\n![immagine](immagine.asy?v=variants.py)\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Siccome non si possono rimuovere libri, tutte le pile devono raggiungere l'altezza della pila più alta.\n> Quindi il risultato si ottiene sommando per ogni pila la differenza di altezza tra la pila più alta e quella pila:\n> in questo caso $\\js{h-altezze[0]} + \\js{h-altezze[1]} + \\js{h-altezze[2]} + \\js{h-altezze[3]} + \\js{h-altezze[4]} = \\js{ans1}$.\n\n---\n\nOsservando ancora meglio le pile, hai pensato che non solo potresti **aggiungere** nuovi libri prendendoli dalla tua riserva, ma potresti anche **spostare** i libri che ci sono da una pila all'altra.\nQuanti libri dovresti **spostare o aggiungere** al minimo, per portare tutte le pile alla stessa altezza?\n\n- [x] $\\js{ans2}$\n- [ ] $\\js{wrong2[0]}$\n- [ ] $\\js{wrong2[1]}$\n- [ ] $\\js{wrong2[2]}$\n- [ ] $\\js{wrong2[3]}$\n\n> Spostare i libri è sempre conveniente rispetto ad aggiungere, perché alza la pila più bassa mentre abbassa la pila più alta, avvicinando le altezze delle pile.\n> Spostando i libri, possiamo portare tutte le pile all'altezza media arrotondata per eccesso, che in questo caso è $\\js{hf}$.\n> Il numero di aggiunte o spostamenti sarà quindi pari a quanto manca ad ogni pila per arrivare a $\\js{hf}$, contando zero per le pile già più alte:\n> $\\js{Math.max(hf-altezze[0],0)} + \\js{Math.max(hf-altezze[1],0)} + \\js{Math.max(hf-altezze[2],0)} + \\js{Math.max(hf-altezze[3],0)} + \\js{Math.max(hf-altezze[4],0)} = \\js{ans2}$.\n","import variants from \"./variants.py\";\n\nOggi hai comprato alcuni frutti e poi hai provato a pesarli sulla tua bilancia, come vedi qui:\n\n<div class=\"print:hidden\">\n![scale1](scale1.asy?v=variants.py)\n![scale2](scale2.asy?v=variants.py)\n</div>\n\n<div class=\"hidden print:block\">\n![scale1](scale1.asy?v=variants.py)\n\n![scale2](scale2.asy?v=variants.py)\n</div>\n\nIn tutte e due le prove le bilance sono squilibrate: il peso totale degli oggetti a sinistra è meno del peso totale degli oggetti a destra.\nSai che i frutti di tipo uguale pesano tutti uguale. Qual è l'ordine di peso dei frutti (dal più leggero al più pesante)?\n\n- [ ] <span>![A](A.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![B](B.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![C](C.asy?v=variants.py&s=0.6)</span>\n- [ ] <span>![D](D.asy?v=variants.py&s=0.6)</span>\n- [x] <span>![E](E.asy?v=variants.py&s=0.6)</span>\n\n> Dalla prima pesata, togliendo da entrambi i piatti una {names[perm[2]]} (frutti uguali hanno sempre lo stesso peso!), capiamo che la {names[perm[0]]} pesa meno che la {names[perm[1]]}.\n> Con la seconda pesata capiamo invece che la {names[perm[2]]} pesa più della {names[perm[1]]}. Infatti, se sostituiamo nel piatto destro la {names[perm[0]]} con la {names[perm[1]]}\n> (che è più pesante), quel piatto deve rimanere il più pesante.\n> Di conseguenza l'ordine è {names[perm[0]]} (leggero) - {names[perm[1]]} (medio) - {names[perm[2]]} (pesante).\n\n---\n\nVisto che hai anche comprato alcune verdure (patate, carote e melanzane), provi a pesare anche quelle sulla bilancia:\n\n<div class=\"print:hidden\">\n![scale3](scale3.asy?v=variants.py)\n![scale4](scale4.asy?v=variants.py)\n</div>\n\n<div class=\"hidden print:block\">\n![scale3](scale3.asy?v=variants.py)\n\n![scale4](scale4.asy?v=variants.py)\n</div>\n\nDa questi risultati, cosa puoi dedurre sul peso di queste tre verdure?\n\n- [x] la {names[perm[3]]} è la più leggera, ma non si può sapere niente sulle altre due verdure\n- [ ] la {names[perm[3]]} è la più leggera, la {names[perm[5]]} è intermedia e la {names[perm[4]]} è la più pesante\n- [ ] la {names[perm[5]]} è la più leggera, ma non si può sapere niente sulle altre due verdure\n- [ ] la {names[perm[4]]} è la più leggera, la {names[perm[5]]} è intermedia e la {names[perm[3]]} è la più pesante\n- [ ] non si può dedurre niente sui pesi delle tre verdure\n\n> Togliendo da ognuna delle pesate le verdure presenti su entrambi i piatti, possiamo vedere che sia la {names[perm[4]]} che la {names[perm[5]]}\n> sono più pesanti della media delle altre due verdure. L'unico caso in cui questo può succedere è se la {names[perm[3]]} è la verdura più leggera.\n> Invece, non possiamo dire nulla su {names[perm[4]]} e {names[perm[5]]}: infatti, la seconda pesata è identica alla prima scambiando\n> {names[perm[4]]} con {names[perm[5]]}, e quindi tutto quello che si potrebbe dire di una delle due verdure si dovrebbe poter dire anche dell'altra.","import variants from \"./variants.py\";\n\nA Olinfolandia ci sono 12 città collegate da strade. Solo alcune di queste strade, tuttavia, sono ad alta velocità (rosso tratteggiato):\n\n![immagine](immagine.asy?v=variants.py)\n\nQual è il numero minimo di strade normali (nere) che dovrebbero essere potenziate ad alta velocità (colorate di rosso), di modo che sia possibile raggiungere qualsiasi città partendo da qualsiasi altra città percorrendo solo strade ad alta velocità?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Olinfolandia è descritto da un insieme di città collegate da strade. In informatica questo si chiama _grafo_, chiamando _nodi_ i punti (in questo caso le città) e _archi_ i collegamenti (in questo caso le strade).\n> Quando si studiano i grafi, sono spesso importanti le _componenti connesse_: ovvero quegli insiemi di nodi tali per cui tutti i nodi di una stessa componente connessa si possono raggiungere l'un l'altro\n> tramite gli archi del grafo, mentre non ci sono archi che collegano componenti connesse diverse.\n>\n> Nel caso di Olinfolandia disegnato in figura, possiamo contare le componenti connesse considerando **solo** le strade ad alta velocità (rosso tratteggiato), che sono $\\js{ans1_plus}$ (attenzione: anche i singoli\n> nodi scollegati da tutto contano come componenti connesse!). Per ogni strada che potenziamo ad alta velocità, il numero di componenti connesse diminuisce al massimo di una unità. Quindi, se vogliamo arrivare\n> a collegare tutte le città (e quindi ad avere una sola componente connessa), dobbiamo aggiungere $\\js{ans1_plus} - 1 = \\js{ans1}$ strade.\n\n---\n\nOra vorresti sapere anche quanto ti _costerebbe_ al minimo collegare tutta Olinfolandia all'alta velocità, sapendo che ogni strada normale ha un diverso costo per essere potenziata (il numero riportato sopra la strada). Qual è il costo totale minimo?\n\n?> {ans2}\n\n> Sappiamo dalla domanda precedente che dobbiamo aggiungere $\\js{ans1}$ strade: ora dobbiamo scegliere quali per minimizzare il costo.\n> Aggiungiamo quindi le strade una alla volta, considerando solo strade utili (che uniscono due diverse componenti connesse).\n> Quando possiamo scegliere tra più strade, visto che vogliamo minimizzare il costo, scegliamo sempre **quella che costa meno**.\n> Seguendo questo procedimento fino a collegare tutte le città otteniamo la risposta ottimale, che è $\\js{ans2}$.\n>\n> **Approfondimento**: in informatica, questo algoritmo viene chiamato [_Algoritmo di Kruskal_](https://it.wikipedia.org/wiki/Algoritmo_di_Kruskal) per calcolare il _minimo albero ricoprente_.","import variants from \"./variants.py\";\n\nHai appena aperto un allevamento di conigli. L'allevamento comprende diverse aree, collegate da percorsi secondo questa struttura ad albero:\n\n![allevamento](immagine1.asy?v=variants.py)\n\nAlcune delle aree dell'allevamento contengono conigli, altre contengono dei campi di carote. I percorsi interni invece possono essere bloccati da una recinzione, indicata nello schema da un lucchetto, che i conigli non possono attraversare. Nella configurazione sopra, quante sono le **diverse coppie** (coniglio, carota) per cui il coniglio può raggiungere la carota? Le coppie possono anche avere conigli e carote in comune tra loro\n\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[3]}$\n\n> Dato che il nodo con il lucchetto non può essere mai attraversato, possiamo \n> rimuoverlo dall'albero. Questo ci lascia una configurazione formata da $3$\n> alberi scollegati. Per ogni albero contiamo il numero di conigli $A$ e carote $B$, e moltiplichiamo\n> tra loro questi due valori per ottenere la risposta parziale di quest'albero \n> $R_{albero} = A \\cdot B$. Per entrambi gli alberi che stavano sotto al nodo con il lucchetto,\n> il numero sarà quindi zero, visto che contengono rispettivamente solo conigli e solo carote.\n> L'albero rimanente ha $\\js{factor}$ carote e $\\js{ans1/factor}$ conigli, per cui la risposta è \n> $\\js{factor} \\times \\js{ans1/factor} = \\js{ans1}$.\n\n---\n\nL'ora del pranzo è terminata, e ora vuoi evitare che i conigli possano raggiungere ancora le carote. Se l'allevamento segue questo schema:\n\n![allevamento](immagine2.asy?v=variants.py)\n\nQuanti percorsi interni (cerchi bianchi) devi bloccare al minimo di modo che nessun coniglio possa raggiungere nessuna carota?\n\n- [ ] $\\js{wrong2[0]}$\n- [x] $\\js{ans2}$\n- [ ] $\\js{wrong2[1]}$\n- [ ] $\\js{wrong2[2]}$\n- [ ] $\\js{wrong2[3]}$\n\n> Definiamo _radice_ dell'albero il nodo più in alto tra tutti.\n> Possiamo risolvere il problema tramite il seguente algoritmo. Facciamo\n> una [_visita_](https://it.wikipedia.org/wiki/Ricerca_in_profondit%C3%A0)\n> dell'albero dal basso verso l'alto (prima di visitare un nodo, visitiamo\n> tutti i suoi figli). Mentre che visitiamo i nodi faremo due cose:\n> assegnare i lucchetti, ma anche segnarci come **_stato_** del nodo ciò che si\n> può raggiungere scendendo da quel nodo (niente, conigli o carote).\n>\n> Quando visitiamo un nodo, innanzitutto raccogliamo lo **_stato_** di tutti i\n> suoi _figli_ (nodi direttamente collegati e più in basso), e facciamo l'unione di tutti questi\n> stati. Il risultato che ne consegue, che chiamiamo **_totale_**, può essere:\n>\n> - _conigli e carote_: in tal caso mettiamo un lucchetto nel nodo corrente, e ne assegnamo lo **_stato_** a _niente_ (il lucchetto impedisce di visitare altro!).\n> - _niente_, solo _conigli_ o solo _carote_: in tal caso non mettiamo un lucchetto e assegnamo lo **_stato_** del nodo corrente a **_totale_**.\n>\n> Questa procedura ci fornisce la risposta ottimale, che è $\\js{ans2}$.\n> Un possibile piazzamento è rappresentato in figura:\n>\n> ![allevamento](immagine3.asy?v=variants.py)\n","import variants from \"./variants.py\";\n\nNel nuovo centro commerciale _WallMars_ ci sono $\\js{n}$ porte automatiche, inizialmente tutte disattivate, e ognuna collegata\nad un interruttore per attivarne il funzionamento. Da una soffiata anonima, hai scoperto che **esattamente uno** degli interruttori è rotto, ma non sai quale e devi scoprirlo!\n\n![WallMars](wallmars.jpg)\n\nOgni minuto puoi fare esattamente una di queste 2 azioni:\n\n1. azionare un interruttore: se è quello rotto non succede nulla, altrimenti cambia lo stato della porta (da disattiva a attiva oppure da attiva a disattiva, ma senza scoprire se alla fine è attiva o disattiva);\n2. controllare se una data porta è attiva o disattiva.\n\nDi quanti minuti hai bisogno al minimo per essere sicuro di capire qual è l'interruttore rotto, anche se sei sfortunato?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Una strategia ottimale è la seguente.\n>\n> Provo ad azionare il primo interruttore (1 minuto), poi controllo se la porta è attiva (1 minuto).\n> Nel caso non sia attiva, allora mi fermo perché ho trovato l'interruttore rotto, altrimenti passo a quello dopo.\n> Il caso peggiore è quello in cui l'interruttore rotto è l'ultimo che viene controllato.\n> In questo caso si impiegherebbero $2 \\cdot \\js{n} = \\js{2*n}$ minuti, ma possiamo fare di meglio!\n>\n> Dato che è garantito che c'è almeno un interruttore rotto, possiamo evitare di \n> controllare l'ultima porta. Questo perché se non abbiamo trovato la porta guasta \n> nelle prime $\\js{n}-1$ porte, allora deve per forza essere l'ultima! La risposta è \n> quindi $2 \\cdot \\js{n} - 2 = \\js{2*n} - 2 = \\js{ans1}$.\n\n---\n\nDopo averci pensato meglio, ti sei accorto che c'è una terza azione che puoi fare, sempre nel tempo di un minuto:\n\n1. misurare il consumo elettrico totale di _WallMars_, capendo così esattamente quante porte sono attive in quel momento.\n\nCon quest'altra possibilità, e le due precedenti, di quanti minuti hai bisogno per capire qual è l'interruttore rotto?\n\n?> {ans2}\n\n> In questo caso si può adottare una tecnica chiamata [_ricerca binaria_](https://it.wikipedia.org/wiki/Ricerca_dicotomica).\n>\n> Dividiamo a metà l'intervallo e attiviamo tutte le porte nella prima metà ($\\js{n} / 2$ minuti).\n> Ora misuriamo quante porte attive ci sono nella prima parte (1 minuto). Se ce ne sono\n> meno rispetto a quelle che abbiamo attivato, allora sappiamo che la porta\n> guasta si trova nella prima metà ed è l'unica porta ancora disattivata. \n> Se invece ci sono tante porte attive quante ce ne aspettiamo, la porta guasta si trova\n> nella seconda metà.\n>\n> In entrambi i casi, ci siamo ricondotti ad un intervallo di metà delle porte, di cui\n> sappiamo quante sono attive al momento. Ora possiamo considerare _metà_ di questa _metà_\n> di porte, premere tutti gli interruttori corrispondenti ($\\js{n} / 4$ minuti), e poi\n> misurare il numero di porte attive in totale (1 minuto). Se il numero di porte attive\n> cambia del numero di interruttori premuti meno uno ($\\js{n} / 4 - 1$), allora la porta\n> guasta si trova nell'intervallo per cui abbiamo premuto gli interruttori, altrimenti si\n> trova nell'altro quarto. In ogni caso, ci siamo ricondotti ad un quarto delle porte.\n> \n> Ripetiamo questa procedura fino ad arrivare ad un intervallo di 2 porte, per individuare\n> quale delle due è quella guasta. Il numero di minuti che ci chiede questo procedimento è:\n>\n> $\\js{n} / 2 + 1$\n>\n> $+ \\js{n} / 4 + 1$\n>\n> $\\ldots$\n>\n> $+ 2 + 1$\n>\n> $+ 1 + 1$\n>\n> Il numero di righe nel calcolo sopra è pari a $\\log_2{\\js{n}} = \\js{k}$, e in ciascuna riga\n> abbiamo un $+1$. Inoltre, la somma degli altri termini di ogni riga è pari a\n> $\\js{n} / 2 + \\js{n} / 4 + \\ldots + 4 + 2 + 1 = \\js{n} - 1 = \\js{n-1}$.\n> Quindi in totale questo approccio usa $\\js{n-1} + \\js{k} = \\js{ans2}$ operazioni.\n","import variants from \"./variants.py\";\n\nVuoi andare a fare una passeggiata in montagna, portandoti dietro {panini} panini:\n\n![montagne](fig.asy?v=variants.py)\n\nLa passeggiata prevede {length} tratti di percorso e passa per alcuni chioschi del pane. In ogni tratto seguirai questo procedimento, partendo dall'inizio del tratto:\n\n```srs\nif chiosco() then\n    compra_panini(2)\n    if salita() then\n        mangia_panini(2)\n    end if\nelse\n    if salita() then\n        mangia_panini(1)\n    end if\nend if\ncammina()\n```\n\n![code](code.asy?s=0.7)\n\nCon quanti panini rimarrai alla fine del percorso?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] non ti rimarrà nessun panino\n\n> In ogni posizione abbiamo quattro possibili situazioni:\n> \n> - c'è un chiosco e la strada è in salita (compri $2$ panini ma li mangi subito);\n> - c'è un chiosco e la strada è in discesa (compri $2$ panini);\n> - non c'è un chiosco e la strada è in salita (mangi $1$ panino);\n> - non c'è un chiosco e la strada è in discesa.\n>\n> Quindi, nel primo e nell'ultimo caso il numero di panini non cambia.\n> A questo punto è sufficiente contare quante volte si presentano il \n> secondo e terzo caso, moltiplicarli per le loro rispettive variazioni \n> di panini e aggiungere i panini iniziali. La risposta è quindi\n> $\\js{panini} + \\js{sol1[0]} \\cdot 2 - \\js{sol1[1]} \\cdot 1 = \\js{ans1}$.\n\n---\n\nUna volta arrivato, ti sei accorto di aver dimenticato i panini!\nC'è solo una soluzione: sperare che aprano altri chioschi nel frattempo. I chioschi possono aggiungersi all'inizio di ogni tratto (incluso il primo) in cui non c'è già un chiosco.\nQuanti chioschi dovrebbero aggiungersi **al minimo**, perché tu possa riuscire ad arrivare fino in fondo al percorso rispettando il procedimento, e partendo **senza panini**?\n\n- [x] $\\js{ans2}$\n- [ ] $\\js{wrong2[0]}$\n- [ ] $\\js{wrong2[1]}$\n- [ ] $\\js{wrong2[2]}$\n- [ ] non serve aggiungere nessun chiosco\n\n> Proviamo a simulare il percorso partendo senza panini. Ogni volta che ci ritroveremmo\n> a dover mangiare un panino ma non ne abbiamo, andiamo ad aggiungere un chiosco in una\n> posizione libera nella parte di percorso dall'inizio fino alla posizione corrente.\n> Ci conviene sempre aggiungere un chiosco in un tratto in discesa, se ce n'è uno senza\n> chioschi, perché in quel caso guadagnamo due panini. Se non è possibile, ci accontentiamo\n> di aggiungerlo in un tratto in salita, e in quel caso guadagnamo un solo panino (perché\n> evitiamo di perdere 1 panino in quel tratto in salita). Simulando questo procedimento\n> troviamo la soluzione, che richiede di aggiungere $\\js{ans2}$ chioschi:\n>\n> ![soluzione](sol.asy?v=variants.py)\n","import variants from \"./variants.py\";\n\n\nLa città di _Scart City_ è famosa per le sue numerose discariche. Ogni discarica ha un _livello di odorosità_ $k$, che vuol dire che se ne sente l'odore in tutte le case fino ad una distanza di $k$. Per esempio, in questa configurazione solo la casa più a destra è abbastanza lontana dalla discarica:\n\n![esempio](esempio0.asy)\n\nVuoi acquistare alcune case nel _quartiere stretto_, che è una linea di $\\js{l}$ isolati come in figura:\n\n![quartiere stretto](part1.asy?v=variants.py)\n\nQuante sono le case del quartiere stretto da cui non si sente l'odore di nessuna discarica?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Se simuliamo la situazione descritta su un pezzo di carta,\n> escludendo le case troppo vicine ad una discarica e contando quelle valide,\n> otteniamo che la risposta è $\\js{ans1}$.\n>\n> ![soluzione](part1sol.asy?v=variants.py)\n\n---\n\nSei anche interessato alle case nel _quartiere quadro_, che è composto da $\\js{n} \\times \\js{m}$ isolati come in figura:\n\n![quartiere quadro](part2.asy?v=variants.py)\n\nAttenzione che l'odore **a ogni passo** si propaga a tutti gli isolati direttamente adiacenti, ma **non in diagonale** (ma diversi passi di propagazione possono avvenire in direzioni diverse).\nPer esempio, in questa configurazione ci sono $8$ case abbastanza lontane dalla discarica:\n\n![esempio](esempio1.asy)\n\nQuante sono le case del quartiere quadro da cui non si sente l'odore di nessuna discarica?\n\n- [x] $\\js{ans2}$\n- [ ] $\\js{wrong2[0]}$\n- [ ] $\\js{wrong2[1]}$\n- [ ] $\\js{wrong2[2]}$\n- [ ] $\\js{wrong2[3]}$\n\n> Anche in questo caso è possibile simulare la situazione descritta, come nella prima domanda.\n> Il modo migliore è riportare la mappa su un pezzo di carta, e poi segnare le aree verso\n> cui si espande l'odore di ciascuna discarica, come nella figura seguente. Contando le aree\n> che restano fuori dall'espansione di ogni discarica otteniamo la risposta, che è $\\js{ans2}$.\n>\n> ![soluzione](part2sol.asy?v=variants.py)\n>\n> **Approfondimento:** l'espansione dell'odore da una discarica si può pensare come ad una\n> [_visita in ampiezza_](https://it.wikipedia.org/wiki/Ricerca_in_ampiezza) sulle celle della\n> griglia, fino ad una certa ampiezza massima data.\n","import variants from \"./variants.py\";\n\nUn _array_ $a$ di lunghezza $n$ è una sequenza di numeri interi indicizzati da zero, che indichiamo con $a[0], a[1], \\ldots a[n-1]$.\n\nDurante la tua ultima passeggiata in montagna, hai trovato due array lungo il percorso: `nero` e `rosso`, entrambi della stessa lunghezza $n = \\js{n}$.\nRappresentando `nero[x]` con una freccia nera da `x` a `nero[x]`, e `rosso[x]` con una freccia rossa tratteggiata da `x` a `rosso[x]`, gli array sono:\n\n![rappresentazione](fig.asy?v=variants.py)\n\nVorresti ora passeggiare lungo i due array seguendo questo procedimento, dato un certo valore `y` che devi scegliere:\n\n```srs\nx <- 0\nwhile x != n - 1 do\n    if x == y then\n        x <- rosso[x]\n    else\n        x <- nero[x]\n    end if\nend while\n```\n\n![code](code.asy?s=0.7)\n\nQuanti diversi valori di `y` tra $0$ e $\\js{n-1}$ potresti scegliere di modo che la passeggiata termini, senza andare avanti all'infinito?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] non ce ne sono, la passeggiata va sempre avanti all'infinito\n\n> Potremmo risolvere il problema simulando la passeggiata per ogni possibile valore di `y`.\n> Ma possiamo fare di meglio! Leggendo il programma, capiamo che la passeggiata parte\n> dalla posizione `x` uguale a zero (inizio dell'array), e si ferma se raggiungiamo la\n> posizione `x` uguale a `n-1` (fine dell'array). A ogni passo, nella passeggiata seguiamo\n> un arco nero, a meno che `x` sia proprio uguale a `y`: solo in quel caso seguiamo un arco rosso.\n> \n> Nota che i primi $\\js{ans2}$ elementi neri formano un ciclo,\n> e i successivi $\\js{n-ans2}$ elementi formano un secondo ciclo.\n> Dato che `x` parte da zero (nel primo ciclo), e la passeggiata\n> termina in `n-1` (nel secondo ciclo), l'unico modo per cui la\n> passeggiata non vada avanti all'infinito è che l'arco rosso\n> che parte in posizione `y` ci consenta di uscire dal primo\n> ciclo e arrivare nel secondo, cioè `y` deve essere minore di\n> $\\js{ans2}$ e `rosso[y]` deve essere maggiore o uguale a $\\js{ans2}$.\n>\n> Questi valori si possono vedere facilmente nella figura,\n> scandendo gli archi dalla prima alla seconda metà dell'array,\n> che sono $\\js{ans1}$. \n\n---\n\nOltre a non voler passeggiare all'infinito, vorresti anche assicurarti di visitare **tutte le posizioni** tra $0$ e $\\js{n-1}$.\nPer fortuna, ti sei accorto che potresti anche modificare un valore dell'array `rosso`!\nPer quale coppia di valori `y` e `rosso[y]` riusciresti a visitare tutti i numeri?\n\nIndica la risposta come **AB**, dove **A** è il valore di `y` e **B** è il nuovo valore da assegnare a `rosso[y]`.\n\n?> {ans2-1}{ans2}\n\n> Dal ragionamento di prima, sappiamo che `y` deve essere nella prima metà\n> dell'array e `rosso[y]` nella seconda. Dati tali valori, notiamo che la\n> passeggiata salterebbe tutti i valori intermedi tra `y` e `rosso[y]`.\n> Segue che `y` e `rosso[y]` devono essere consecutivi, e quindi\n> `y` $= \\js{ans2-1}$ e `rosso[y]` $= \\js{ans2}$. ","import variants from \"./variants.py\";\n\nHai comprato un nuovo robot tuttofare, e vuoi fargli pulire casa! Il suo appartamento è composto da una sequenza di {length} stanze una dopo l'altra. Le stanze sono separate da porte, e ciascuna ha un interruttore che regola la luce della stanza successiva. Inizialmente, il robot si trova nella stanza 1, e le luci e porte sono in questo stato (le porte chiuse sono quelle verticali che sbarrano la strada al robot, impedendogli di avanzare):\n\n![appartamento](fig.asy?v=variants.py)\n\nHai programmato il robot per seguire questo procedimento:\n\n```srs\nwhile luce_accesa() do\n    if porta_chiusa() then\n        premi_interruttore()\n        apri_porta()\n    end if\n    avanza()\nend while\n```\n\n![code](code.asy?s=0.7)\n\nDove si troverà il robot alla fine del procedimento?\n\n- [x] nella stanza $\\js{ans1}$\n- [ ] nella stanza $\\js{wrong1[0]}$\n- [ ] nella stanza $\\js{wrong1[1]}$\n- [ ] nella stanza $\\js{wrong1[2]}$\n- [ ] il robot esce dall'appartamento\n\n> Il robot preme l'interruttore ogni volta che incontra una porta chiusa.\n> Quindi può procedere fintanto che le luci già accese solo precedute da\n> una porta aperta, e le luci spente sono precedute da una porta chiusa.\n> Si ferma quindi alla prima stanza che sia o accesa dopo una porta chiusa,\n> oppure spenta dopo una porta aperta: nel nostro caso questa stanza è la $\\js{ans1}$.\n\n---\n\nNon sei molto convinto del procedimento che hai programmato prima, allora hai deciso di modificarlo di modo che **qualunque** sia lo stato delle porte e delle luci, il robot arrivi sempre fino alla fine dell'appartamento,\n**a patto che la luce nella stanza iniziale sia accesa**.\nPurtroppo però il robot ha una programmazione molto vincolata! Devi per forza tenere il ciclo \"ripeti mentre\" più esterno, mentre al suo interno puoi mettere in sequenza i blocchi di istruzioni che preferisci, scegliendo tra questi 5 possibili:\n\n<div class=\"print:hidden\">\n![code](code-alt1.asy?v=variants.py)\n![code](code-alt2.asy?v=variants.py)\n![code](code-alt3.asy?v=variants.py)\n</div>\n\n<div class=\"hidden print:block\">\n![code](code-alt1.asy?v=variants.py)\n\n![code](code-alt2.asy?v=variants.py)\n\n![code](code-alt3.asy?v=variants.py)\n</div>\n\nPer riportare la programmazione al robot, devi quindi scrivere una sequenza di numeri da 1 a 5 (anche ripetuti), che corrisponde ai blocchi di istruzioni da eseguire nel ciclo.\nPer esempio, il programma riportato nella domanda precedente corrisponde al programma **{perm[3]}{perm[1]}**, ma purtroppo non sempre consente al robot di arrivare in fondo all'appartamento.\nQuale sarebbe invece un programma corretto? Tieni conto che il robot non può avanzare se la porta è chiusa, e in caso di più programmi corretti, riporta **quello più corto (con meno istruzioni)**.\n\n?> {perm[0]}{perm[1]}{perm[2]}\n\n> Osserviamo che il ciclo più esterno richiede una luce accesa per continuare.\n> Ciò vuol dire che al robot è permesso entrare in una stanza con la luce spenta,\n> a patto che, quando sono terminate tutte le istruzioni del ciclo, la luce della\n> stanza in cui si trova al momento sia accesa.\n> \n> In qualunque posizione si trovi il robot, prima di poter avanzare deve\n> aprire la porta, segue quindi che il primo blocco di istruzioni dovrà essere\n> o il **blocco {perm[0]}** oppure il **blocco {perm[3]}**.\n> Dato che il robot non può sapere se la luce è accesa senza entrare nella stanza,\n> a questo punto non gli resta che avanzare con il **blocco {perm[1]}**.\n> Tuttavia, in questo momento il robot potrebbe trovarsi in una stanza con la luce\n> spenta, il che lo porterebbe a fermarsi. Per evitare che questo accada deve\n> usare il **blocco {perm[2]}**, che in caso la luce sia spenta lo fa arretrare,\n> premere l'interruttore nella stanza prima (accendendo la luce), e poi avanzare\n> di nuovo per tornare nella stanza corrente.\n>\n> Entrambe le scelte del primo blocco portano il robot ad arrivare fino in fondo,\n> però il **blocco {perm[0]}** contiene meno istruzioni. La soluzione è quindi\n> usare il **blocco {perm[0]}**, poi **blocco {perm[1]}**, poi **blocco {perm[2]}**,\n> per cui la risposta è **{perm[0]}{perm[1]}{perm[2]}**.\n","import variants from \"./variants.py\";\n\nUn _array_ $a$ di lunghezza $n$ è una sequenza di numeri interi indicizzati da zero, che indichiamo con $a[0], a[1], \\ldots a[n-1]$.\n\nDurante una pausa dallo studio del greco antico hai scoperto la funzione `ribalta`! Questa funzione dato un `array`, un indice di `inizio` e una `lunghezza`, modifica l'array invertendo l’ordine dei suoi primi `lunghezza` elementi a partire da `array[inizio]`:\n\n```srs\nfunction ribalta(array: integer[], inizio: integer, lunghezza: integer)\n    fine <- inizio + lunghezza - 1\n    for i in [0 ... lunghezza / 2) do\n        (array[inizio + i], array[fine - i]) ← (array[fine - i], array[inizio + i])\n    end for\nend function\n```\n\n![ribalta](ribalta.asy?s=0.7)\n\nOra vuoi usare questa funzione per generare un codice segreto!\nDato un `array` di lunghezza totale $t = \\js{l1}$, esegui questo procedimento:\n\n```srs\nfor i in [0 ... t) do\n    array[i] <- i\nend for\nlen <- t\nwhile len >= 2 do\n    for i in [0 ... t / len) do\n        ribalta(array, i * len, len)\n    end for\n    len <- len / 2\nend while\n```\n\n![code](code.asy?s=0.7)\n\nAlla fine del procedimento, che numero sarà contenuto in `array[{x1}]`?\n\n- [x] $\\js{ans1}$\n- [ ] $\\js{wrong1[0]}$\n- [ ] $\\js{wrong1[1]}$\n- [ ] $\\js{wrong1[2]}$\n- [ ] $\\js{wrong1[3]}$\n\n> Proviamo a replicare il procedimento passo dopo passo.\n> Dopo il primo ciclo for (contatore), l'array conterrà i valori:\n>\n> $[0, 1, 2, 3, 4, 5, 6, 7]$\n>\n> A questo punto inizia il ciclo while (ripeti mentre) con `len` pari a 8.\n> Questa prima iterazione chiama la funzione `ribalta` una sola volta, con\n> $i = 0$, su tutto l'array. Questo ribalta tutti i valori, ottenendo:\n>\n> $[7, 6, 5, 4, 3, 2, 1, 0]$\n>\n> Nella seconda iterazione, `len` diventa pari a 4. Quindi viene chiamata la\n> funzione `ribalta` due volte, con $i= 0$ e $1$, sulla prima metà e poi sulla\n> seconda metà dell'array. A questo punto, `array` diventa:\n>\n> $[4, 5, 6, 7, 0, 1, 2, 3]$\n>\n> Similmente, nella terza iterazione vengono ancora ribaltati tutti gli elementi\n> dell'array a coppie, ottenendo:\n>\n> $[5, 4, 7, 6, 1, 0, 3, 2]$\n>\n> Ne segue che `array[{x1}]` è pari a $\\js{ans1}$ (attenzione che gli indici partono da zero).\n\n---\n\nNon essendo soddisfatto di un codice così corto, decidi di ripetere il procedimento con un `array` di lunghezza totale $t = \\js{l2}$.\nAlla fine del procedimento, che numero sarà contenuto in `array[{x2}]`?\n\n?> {ans2}\n\n> Questa volta non possiamo replicare il procedimento passo dopo passo, ma dobbiamo ragionare sul suo comportamento in generale.\n> All’inizio l’array contiene `array[i] = i`.\n> A ogni iterazione, il procedimento applica una serie di ribaltamenti su tutti i blocchi di una data lunghezza `len` dell'array.\n> Se pensiamo alla rappresentazione binaria dei valori dell'array, questi ribaltamenti **invertono i `len` bit meno significativi**\n> di ogni valore nell'array.\n>\n> La prima iterazione inverte quindi tutti i bit; la seconda tutti i bit tranne quello più significativo, e così via.\n> In totale, il bit più significativo viene invertito una volta, il secondo più significativo due volte, eccetera:\n> dato che invertire un bit due volte equivale a non fare niente, possiamo considerare che il procedimento alla fine\n> inverte i bit in posizione dispari di tutti gli elementi (contando le posizioni a partire dal bit più significativo).\n>\n> Dato che $1024 = 2^{10}$, dobbiamo considerare la rappresentazione binaria in 10 bit.\n> Inizialmente `array[{x2}] = {x2}`, che in binario corrisponde a `{b2}`. Invertendo i bit dispari dal più significativo,\n> otteniamo `{i2}`, che in decimale corrisponde a $\\js{ans2}$.","<Contest>\n\n## Sezione 1: Esercizi logico-algoritmici\n\n<Section>\n    <Problem points={[5, 1, 0]}><A3SPileDiLibri/></Problem>\n    <Problem points={[5, 1, 0]}><A4SFruttiMisteriosi /></Problem>\n    <Problem points={[5, 1, 0]}><A5PianificazioneStradale/></Problem>\n    <Problem points={[5, 1, 0]}><A6AlberiBloccati/></Problem>\n    <Problem points={[5, 1, 0]}><A7Discariche/></Problem>\n    <Problem points={[5, 1, 0]}><A8Lampadine/></Problem>\n</Section>\n\n## Sezione 2: Esercizi di programmazione\n\n<Section>\n    <Problem points={[5, 1, 0]}><P3SPaniniChioschi/></Problem>\n    <Problem points={[5, 1, 0]}><P4SLuciPorte/></Problem>\n    <Problem points={[5, 1, 0]}><P5RossoENero/></Problem>\n    <Problem points={[5, 1, 0]}><P6ArrayEBit/></Problem>\n</Section>\n\n</Contest>\n","Ciao! Ecco le informazioni essenziali sulla prova che stai per svolgere. Ti consigliamo di leggerle attentamente.\n\n## Regole di base\n\nTi è permesso:\n\n- avere a disposizione una calcolatrice (di qualunque tipo, comprese quelle grafiche);\n- avere con te dei fogli bianchi (eventualmente a righe o quadretti);\n- avere con te del materiale di cancelleria (penne, matite, gomma, etc.);\n- andare in bagno (senza dispositivi elettronici o materiale cartaceo);\n- comunicare con il docente sorvegliante in caso di problemi tecnici.\n\nNon ti è permesso:\n\n- se gareggi online, **uscire dalla piattaforma di gara** per qualsiasi motivo;\n- comunicare con i tuoi compagni;\n- comunicare con il docente sorvegliante sul contenuto della prova;\n- diffondere il testo della prova, o parte di esso, prima delle ore 20 dell'ultimo giorno di prova (11 dicembre).\n\n## Formato della prova\n\nLa prova contiene _10 problemi_ da risolvere in _90 minuti_, ed è divisa in due parti:\n- sei problemi di **pensiero logico-algoritmico**, e\n- quattro problemi di interpretazione di **programmi** in pseudocodice o a blocchi.\n\nIn entrambe le parti i problemi sono **in ordine casuale**.\nOgni problema comprende _due domande_, valutate separatamente.\nLa prima è **sempre più semplice**, e può aiutare a rispondere alla seconda (che è solitamente difficile).\n\n## Punteggio\n\nLe domande possono essere a **risposta aperta** numerica; oppure a **scelta multipla** con cinque opzioni, di cui **solo una** è corretta.\nIn ogni caso, il punteggio che puoi ottenere è:\n\n- 5 punti per una risposta _corretta_;\n- 1 punto per una risposta _non data_;\n- 0 punti per una risposta _sbagliata_.\n\n## Quesiti di programmazione e pseudocodice\n\nI quesiti di programmazione presentano semplici programmi scritti in _pseudocodice_. Qui sotto puoi trovare un riassunto della sintassi dello pseudocodice, oppure [scarica qui la guida completa](/Pseudocodice.pdf) in PDF.\n**Quest'anno, per la prima volta, i quesiti di programmazione verranno proposti anche come programma a blocchi:** potrai scegliere di guardare una versione, l'altra o entrambe, a seconda di come ti può essere più congeniale.\n\n![Riassunto guida pseudocodice](pseudocodice-cheatsheet.svg)\n","import { NoAuth } from \"@olinfo/quizms/student\";\n\nimport Contest from \"./contest/contest.mdx\";\nimport Header from \"./header.md\";\n\nexport const metadata = {\n  title: \"Olimpiadi di Informatica\",\n  description: \"Olimpiadi Italiane di Informatica 2025/2026 - Selezione scolastica\",\n};\n\nexport default function App() {\n  return (\n    <NoAuth\n      contestName=\"Olimpiadi di Informatica\"\n      contestLongName={metadata.description}\n      duration={90}>\n      <Header />\n      <Contest />\n    </NoAuth>\n  );\n}\n"],"names":["_jsx","_components","Equation","_jsxs","Image","names","perm","panini","length","Code","metadata","App","jsxs","NoAuth","jsx","Header","Contest"],"mappings":"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"}